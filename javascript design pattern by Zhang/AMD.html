<!DOCTYPE html>
<html>
<head>
	<title>异步模块模式-AMD</title>
	<meta charset="utf-8"/>
</head>
<body>
<div id="demo">demo</div>
<script type="text/javascript">

//闭包环境
	//向闭包中传入模块管理器对象F（~屏蔽压缩文件时，前面漏写;报错。)
~(function(F) {
	//模块缓存器，存储已经创建的模块
	var moduleCache = {};
//创建与调度模块
	/***
	 *创建或调用模块方法.遍历所有依赖模块，判断是否全部存在为真后才执行回调函数。否则加载相应文件直到加载完成，再执行回调函数。
	 * @param		url			参数为模块url
	 * @param 		deps		参数为依赖模块
	 * @param		callback	参数为模块主函数
	 ***/
	F.module = function() {
		//将参数转化为数组
		var args = [].slice.call(arguments),
		//获取模块构造函数
			callback = args.pop(),
		//获取依赖模块，紧邻回调函数参数，且数据类型为数组
			deps = (args.length && args[args.length-1] instanceof Array ) ? args.pop() : [],
		//该模块url（模块ID）
			Murl = args.length ? args.pop() : null,
			//依赖模块序列
			params = [],
			//未加载的依赖模块数量统计
			depsCount = 0,
			//依赖模块序列中索引
			i = 0,
			//依赖模块序列长度
			len;
		//获取依赖模块长度
		if ( len = deps.length ) {
			//遍历依赖模块
			while ( i < len ) {
				//闭包保存i
				(function(i) {
					//增加未加载依赖模块数量统计
					depsCount++;
					//异步加载依赖模块
					loadModule(deps[i], function(mod) {
						//依赖模块序列中添加依赖模块接口引用
						params[i] = mod;
						//依赖模块加载完成，依赖模块数量统计减一
						depsCount--;
						if ( depsCount === 0) {
							//在模块缓冲区器重校正该模块，并执行构造函数
							setModule(Murl, params, callback);
						}
					});
				})(i);
				//遍历下一模块
				i++;
			}
		//无依赖模块，直接执行回调函数
		} else {
			// 在模块缓存器中校正该模块，并执行构造函数
			setModule(Murl, [], callback);
		}
	}

//设置和加载模块
	var moduleCache = {},
		/***
		 *设置模块并执行模块构造函数
		 * @param moduleName			模块id名称
		 * @param params				依赖模块
		 * @param callback 				 模块构造函数
		 ***/
		setModule = function(moduleName, params, callback) {
			//模块容器， 模块文件加载完成时回调函数
			var _module, fn;
			//如果模块被调用过
			if ( moduleCache[moduleName] ) {
				//获取模块
				_module = moduleCache[moduleName];
				//设置模块已经加载完成
				_module.status = "loaded";
				//校正模块接口
				_module.exports = callback ? callback.apply(_module, params) : null;
				//执行模块文件加载完成回调函数
				while ( fn = _module.onload.shift() ) {
					fn(_module.exports);
				}
			} else {
				//模块不存在（匿名模块）， 则直接执行构造函数
				callback && callback.apply(null, params);
			}
		},
		/***
		 * 异步加载依赖模块所在文件
		 * @params moduleName		模块路径（id）,要和文件的路径对应起来，以备后续loadScript和getUrl使用。
		 * @params callback 		模块加载完成回调函数
		 ***/
		loadModule = function(moduleName, callback) {
		 	//依赖模块
		 	var _module;
		 	//如果依赖模块被要求加载过
		 	if ( moduleCache[moduleName] ) {
		 		//获取该模块信息
		 		_module = moduleCache[moduleName];
		 		//如果模块加载完成
		 		if ( _module.status === "loaded" ) {
		 			//执行模块加载完成回调函数
		 			setTimeout(callback(_module.exports), 0);
		 		} else {
		 			//缓存该模块所处文件加载完成回调函数
		 			_module.onload.push(callback);
		 		}
		 	//模块第一次被依赖引用
		 	} else {
		 		//缓存该模块初始化信息
		 		moduleCache[moduleName] = {
		 			moduleName: moduleName,		//模块id
		 			status: "loading",			//模块对应文件加载状态（默认加载中）
		 			exports: null,				//模块接口
		 			onload: [callback]			//模块对应文件加载完成回调函数缓冲器。
		 		};
		 		//加载模块对应文件
		 		loadScript(getUrl(moduleName));
		 	}
		},

		//获取文件路径。
		getUrl = function(moduleName) {
			return String(moduleName).replace(/\.js$/g, "") + ".js";
		},
		//加载脚本文件
		loadScript = function(src) {
			var _script = document.createElement("script");
			_script.type = "text/javascript";
			_script.charset = "utf-8";
			_script.async = true;
			_script.src = src;
			document.getElementsByTagName("head")[0].appendChild(_script);
		};

})((function() {
	return window.F = {};
})());

	//test，在lib/dom.js中定义dom模块
	

	
	console.log("here2");	
	//在index.html中
	F.module(["lib/event", "lib/do"], function(events, dom) {
		console.log("here");
		events.on("demo", "click", function() {
			dom.html("demo", "success");
		})
	});
</script>
</body>
</html>